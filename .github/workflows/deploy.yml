name: CI/CD to Server

on:
  push:
    branches: [master, dev]

jobs:
  build-test-push:
    if: github.ref_name == 'dev' || github.ref_name == 'master'
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U test"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    env:
      TEST_DATABASE_URL: postgres://test:test@localhost:5432/test_db
      PYTHONUNBUFFERED: 1

    steps:
      - name: Checkout code
        uses: actions/checkout@v3


      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: Run Tests in Docker
        run: |
          docker buildx build --load -t observer-backend-test --target test .
          docker run --rm --env-file .env.test observer-backend-test pytest --maxfail=3 --disable-warnings


      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          target: prod
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/observer-backend:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/observer-backend:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/observer-backend:buildcache,mode=max




  deploy:
    runs-on: ubuntu-latest
    needs: build-test-push

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Determine Deployment Path and Tag
        run: |
          if [[ "${{ github.ref_name }}" == "master" ]]; then
            echo "DEPLOY_PATH=apps/observer-backend" >> $GITHUB_ENV
          elif [[ "${{ github.ref_name }}" == "dev" ]]; then
            echo "DEPLOY_PATH=apps/observer-backend-dev" >> $GITHUB_ENV
          else
            echo "âŒ ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ğ²ĞµÑ‚ĞºĞ°! ĞŸÑ€ĞµÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ."
            exit 1
          fi
          echo "DEPLOY_TAG=${{ github.sha }}" >> $GITHUB_ENV

      - name: ğŸ›  Deploy Backend
        run: |
          echo "ğŸš€ Ğ”ĞµĞ¿Ğ»Ğ¾Ğ¹..."
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=30 ${{ secrets.SSH_USER }}@${{ secrets.SERVER_IP }} << EOF
            export DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
            export DOCKERHUB_TOKEN=${{ secrets.DOCKERHUB_TOKEN }}
            export DEPLOY_TAG=${{ github.sha }}
            export DEPLOY_BRANCH=${GITHUB_REF##*/}

            cd $DEPLOY_PATH || { echo "âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿ĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² $DEPLOY_PATH"; exit 1; }

            git pull origin \$DEPLOY_BRANCH || { echo "âŒ git pull Ğ½Ğµ ÑƒĞ´Ğ°Ğ»ÑÑ"; exit 1; }

            echo "\$DOCKERHUB_TOKEN" | docker login -u "\$DOCKERHUB_USERNAME" --password-stdin \
              || { echo "âŒ Docker login failed"; exit 1; }

            docker pull \$DOCKERHUB_USERNAME/observer-backend:\$DEPLOY_TAG \
              || { echo "âŒ Docker pull failed"; exit 1; }

            if [ ! -f .env ]; then touch .env; fi
            grep -q "^TAG=" .env && sed -i "s/^TAG=.*/TAG=\$DEPLOY_TAG/" .env || echo "TAG=\$DEPLOY_TAG" >> .env
          EOF


      - name: ğŸ§¬ Run Aerich Migrations
        run: |
          echo "ğŸ“¦ ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸..."
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=30 ${{ secrets.SSH_USER }}@${{ secrets.SERVER_IP }} << EOF
            cd $DEPLOY_PATH || exit 1
            export TAG=\$(grep ^TAG .env | cut -d '=' -f2)

            set -e

            if docker compose -f docker-compose.app.yml run --rm aerich; then
              echo "âœ… ĞœĞ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ñ‹ Ğ¸Ğ»Ğ¸ Ğ½Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ»Ğ¸ÑÑŒ"
            else
              echo "âš ï¸ Aerich Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ğ»ÑÑ Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¾Ğ¹"
              echo "ğŸ” Ğ’Ğ¾Ñ‚ Ñ‡Ñ‚Ğ¾ Ğ¾Ğ½ ÑĞºĞ°Ğ·Ğ°Ğ»:"
              docker compose -f docker-compose.app.yml logs aerich || true
            fi


          EOF


      - name: ğŸš€ Start Backend
        run: |
          echo "ğŸš€ ĞŸĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ backend..."
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=30 ${{ secrets.SSH_USER }}@${{ secrets.SERVER_IP }} << EOF
            cd $DEPLOY_PATH || exit 1

            docker compose -f docker-compose.app.yml up -d --force-recreate web > /dev/null \
              && echo "âœ… ĞšĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½" \
              || { echo "âŒ ĞšĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€ Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ğ»ÑÑ"; exit 1; }

            docker image prune -f > /dev/null
          EOF
